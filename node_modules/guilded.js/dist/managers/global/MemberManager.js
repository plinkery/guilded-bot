"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMemberManager = void 0;
const structures_1 = require("../../structures");
const Member_1 = require("../../structures/Member");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = require("@discordjs/collection");
const util_1 = require("../../util");
/**
 * A class representing a manager for Discord server members.
 * @extends CacheableStructManager.
 */
class GlobalMemberManager extends CacheableStructManager_1.CacheableStructManager {
    /**
     * Whether or not social links should be cached.
     */
    get shouldCacheSocialLinks() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheSocialLinks) !== false;
    }
    /**
     * Fetches a member from a server.
     * @param serverId The ID of the server to fetch the member from.
     * @param userId The ID of the member to fetch.
     * @param force Whether to force a fetch from the API.
     * @returns A Promise that resolves with the fetched member.
     */
    fetch(serverId, userId, force) {
        const memberKey = (0, util_1.buildMemberKey)(serverId, userId);
        if (!force) {
            const existingMember = this.client.members.cache.get(memberKey);
            if (existingMember)
                return Promise.resolve(existingMember);
        }
        return this.client.rest.router.members
            .serverMemberRead({ serverId, userId })
            .then((data) => {
            const newMember = new Member_1.Member(this.client, Object.assign(Object.assign({}, data.member), { serverId, id: data.member.user.id }));
            this.client.users.cache.set(data.member.user.id, new structures_1.User(this.client, data.member.user));
            this.client.members.cache.set(memberKey, newMember);
            return newMember;
        });
    }
    /**
     * Fetches all members from a server. Returned objects are partial members.
     * @param serverId The ID of the server to fetch members from.
     * @returns A Promise that resolves with a collection of partial members.
     */
    fetchMany(serverId) {
        return this.client.rest.router.members
            .serverMemberReadMany({ serverId })
            .then((data) => {
            const members = new collection_1.Collection();
            for (const member of data.members) {
                const newMember = new Member_1.PartialMember(this.client, Object.assign({ serverId, id: member.user.id }, member));
                members.set(newMember.id, newMember);
            }
            return members;
        });
    }
    /**
     * Kicks a member from a server.
     * @param serverId The ID of the server to kick the member from.
     * @param userId The ID of the member to kick.
     * @returns A Promise that resolves with the kicked member, or null if the member was not cached.
     */
    kick(serverId, userId) {
        return this.client.rest.router.members
            .serverMemberDelete({ serverId, userId })
            .then((_) => {
            var _a;
            return (_a = this.client.members.cache.get((0, util_1.buildMemberKey)(serverId, userId))) !== null && _a !== void 0 ? _a : null;
        });
    }
    /**
     * Bans a member from a server.
     * @param serverId The ID of the server to ban the member from.
     * @param userId The ID of the user to ban.
     * @returns A Promise that resolves with the banned member, or null if the member was not cached.
     */
    ban(serverId, userId) {
        return this.client.bans.ban(serverId, userId);
    }
    /**
     * Unbans a user from a server.
     * @param serverId The ID of the server.
     * @param userId The ID of the user.
     * @param removeBanIfCached Whether to remove the ban from the cache if it exists.
     * @returns A Promise that resolves with the unbanned member ban or `null` if it isn't cached.
     */
    unban(serverId, userId, removeBanIfCached = false) {
        return this.client.bans.unban(serverId, userId, removeBanIfCached);
    }
    /**
     * Gets a list of the roles assigned to a member using the ID of the member.
     * @param serverId The ID of the server to get the member roles from.
     * @param userId The ID of the member to get the roles for.
     * @returns A Promise that resolves with an array of role IDs.
     */
    getRoles(serverId, userId) {
        return this.client.rest.router.roleMembership
            .roleMembershipReadMany({ serverId, userId })
            .then((data) => data.roleIds);
    }
    /**
     * Updates a member's nickname. Returns the new name.
     * @param serverId The ID of the server to update the member nickname for.
     * @param userId The ID of the member to update the nickname for.
     * @param newNickname The new nickname for the member.
     * @returns A Promise that resolves with the updated nickname.
     */
    updateNickname(serverId, userId, newNickname) {
        return this.client.rest.router.members
            .memberNicknameUpdate({
            serverId,
            userId,
            requestBody: { nickname: newNickname },
        })
            .then((data) => data.nickname);
    }
    /**
     * Deletes a member's nickname.
     * @param serverId The ID of the server to delete the member nickname from.
     * @param userId The ID of the member to delete the nickname for.
     * @returns A Promise that resolves with no value upon completion.
     */
    resetNickname(serverId, userId) {
        return this.client.rest.router.members
            .memberNicknameDelete({ serverId, userId })
            .then(() => void 0);
    }
    /**
     * Awards XP to a member.
     * @param serverId The ID of the server to award XP on.
     * @param userId The ID of the member to award XP to.
     * @param amount The amount of XP to award.
     * @returns A Promise that resolves with the member's new total XP.
     */
    giveXP(serverId, userId, amount) {
        return this.client.rest.router.serverXp
            .serverXpForUserCreate({ serverId, userId, requestBody: { amount } })
            .then((data) => data.total);
    }
    /**
     * Fetch a member's social links.
     * @param serverId The ID of the server.
     * @param userId The ID of the member.
     * @param type The type of social link to fetch.
     * @returns A Promise that resolves with the member's social link.
     */
    fetchSocialLinks(serverId, userId, type) {
        return this.client.rest.router.socialLinks
            .memberSocialLinkRead({ serverId, userId, socialLinkType: type })
            .then((data) => {
            const existingMember = this.cache.get((0, util_1.buildMemberKey)(serverId, userId));
            if (this.shouldCacheSocialLinks)
                existingMember === null || existingMember === void 0 ? void 0 : existingMember.socialLinks.set(data.socialLink.type, data.socialLink);
            return data.socialLink;
        });
    }
}
exports.GlobalMemberManager = GlobalMemberManager;
//# sourceMappingURL=MemberManager.js.map